# -*- coding: utf-8 -*-
"""Final Project.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1LTa6a948-Vf71EX7-5qVZUoNq52ba2iY
"""

# PYTHON CODE FOR PROBLEM 1

# Set Up -----------------------------------------------------------------------

# Imports
import numpy as numpy
from sympy import*
import matplotlib.pyplot

# Symbols
t = Symbol('t')
theta = Symbol('theta')
dtheta = Symbol('dtheta')
ddtheta = Symbol('ddtheta')
Gam = Symbol('Gam')
dGam = Symbol('dGam')
ddGam = Symbol('ddGam')
L, m, g, k = symbols("L,m,g,k")
lo = symbols('lo')


# Functions --------------------------------------------------------------------

def transport(vec, omega):
    # vec is always along the x axis of the reference frame, which is along bar
    # omega is always between the O frame and the reference frame
    # Output is in the format of [x, y]

    # equations solved for using transport theorem by hand
    a_x = -omega*(omega*vec)
    a_y = (omega.diff(dGam) * ddGam)*vec
    return Matrix([[a_x], [a_y]])

# Transformation Matrices & Angular Velocities ---------------------------------

# A frame
# x axis of A frame along AB and DC
T_o_a = Matrix(                               # Transformation for A --> O
        [[-sin(Gam),  cos(Gam)],
         [-cos(Gam), -sin(Gam)]])

omega_o_a = -dGam                             # Ang. Vel. for O --> A

# B frame
# x axis of B frame along BC and AD
T_o_b = Matrix(                               # Transformation for B --> O
        [[sin(Gam), cos(Gam)],
        [-cos(Gam), sin(Gam)]])

omega_o_b = dGam                              # Ang. Vel. for O --> B

# AB_cm ------------------------------------------------------------------------

# Position in Body Frames
AB_cm = L/2                                   # position of OAB_cm in A frame

# Acceleration in Body Frames
a_AB_cm = transport(AB_cm, omega_o_a)         # accel of OAB_cm of in A frame

# Total Acceleration in Inertial frame
a_AB_cm = T_o_a * a_AB_cm                     # accel of OAB_cm in O frame

# BC_cm ------------------------------------------------------------------------

# Position in Body Frames
AB = L                                        # position of OB In A frame
BC_cm = L/2                                   # position of BBC_cm in B frame

# Acceleration in Body Frames
a_AB = transport(AB, omega_o_a)               # accel of OB In A frame
a_BC_cm = transport(BC_cm, omega_o_b)         # accel of BBC_cm In B frame

# Total Acceleration in Inertial frame
a_AB = T_o_a * a_AB                           # accel of OB in O frame
a_BC_cm = T_o_b * a_BC_cm                     # accel of BBC_cm in O frame
a_BC_cm = a_AB + a_BC_cm                      # accel of OBC_cm in O frame

# CD_cm ------------------------------------------------------------------------

# Position in Body Frames
AD = L                                        # position of OD In B frame
CD_cm = L/2                                   # position of DCD_cm In A frame

# Acceleration in Body Frames
a_AD = transport(AD, omega_o_b)               # accel of OD in B frame
a_CD_cm = transport(CD_cm, omega_o_a)         # accel of DCD_cm in A frame

# Total Acceleration in Inertial frame
a_AD = T_o_b * a_AD                           # accel of OD in O frame
a_CD_cm = T_o_a * a_CD_cm                     # accel of DCD_cm in O frame
a_CD_cm = a_AD + a_CD_cm                      # accel of OCD_cm in A frame

# DA_cm ------------------------------------------------------------------------

# Position in Body Frames
DA_cm = L/2                                   # position of ODA_cm In B frame

# Acceleration in Body Frames
a_DA_cm = transport(DA_cm, omega_o_b)         # accel of ODA_cm in B frame

# Total Acceleration in Inertial frame
a_DA_cm = T_o_b * a_DA_cm                     # accel of ODA_cm in O frame

# E1 and E2 --------------------------------------------------------------------

# Spring Forces

# Fs1 is defined at CD instead of AD (which was wriitten in lecture)
Fs1 = k*(2*L*sin(Gam) - lo)     # Spring between B and D, acting on AB and CD
Fs2 = k*(2*L*cos(Gam) - lo)     # Spring between A and C, acting on BC and AD

# Reaction Forces
Ax, Ay, Bx, By, Cx, Cy, Dx, Dy = symbols("Ax,Ay,Bx,By,Cx,Cy,Dx,Dy")

# E1 for each bar, solved by hand
Eq1 = Ax + Bx + Fs1 - m*a_AB_cm[0, 0]          # E1x for AB
Eq2 = Ay + By - m*g - m*a_AB_cm[1, 0]          # E1y for AB
Eq3 = -Bx + Cx - m*a_BC_cm[0, 0]               # E1x for BC
Eq4 = -By + Cy + Fs2 - m*g - m*a_BC_cm[1, 0]   # E1y for BC
Eq5 = -Cx + Dx - Fs1 - m*a_CD_cm[0, 0]         # E1x for CD
Eq6 = -Cy + Dy - m*g - m*a_CD_cm[1, 0]         # E1y for CD
# Eq7 = -Ax - Dx - m*a_DA_cm[0, 0]               # E1x for AD
# Eq8 = -Ay - Dy - Fs2 - m*g - m*a_DA_cm[1, 0]   # E1y for AD

# E2 for AD, solved by hand
Eq9 = -Dx*L*cos(Gam) - Dy*L*sin(Gam) - m*g*L/2*sin(Gam) - 1/3*m*L**2*ddGam

# Getting solution for Diff EQ of Motion ---------------------------------------

# Creating Matrix
Eqns = [Eq1, Eq2, Eq3, Eq4, Eq5, Eq6, Eq9]
vars = [Ax,Ay,Bx,By,Cx,Cy,Dx,Dy,ddGam]

A, b = linear_eq_to_matrix(Eqns, vars)

print(A) # <--- this matrix was identical to matlab solution
print(b)

#A_inv = A.pinv()        # <-- runs infinitely, may be due to nature of matrix
#sol = A.pinv_solve(B)   # <-- runs infinitely, may be due to nature of matrix

# At this stage we were unsure what to do, so we converted the MATLAB solution
# to python to try and see if our method of getting A had anything to do with
# the error

# CONVERTED MATLAB PROBLEM 1 SOLUTION INTO PYTHON

# Define Variables
gam = Function('gam') # gam(t) := th(t)/2 to simplify expression.

Ax, Ay, Bx, By, Cx, Cy, Dx, Dy = symbols("Ax, Ay, Bx, By, Cx, Cy, Dx, Dy")
Gam, Gamd, Gamdd = symbols("Gam, Gamd, Gamdd")

L, m, g, l0, k, Izz = symbols("L, m, g, l0, k, Izz")

# Define coordinates of nodes
A = Matrix([0,0])
B = Matrix([-L*sin(gam(t)), -L*cos(gam(t))])
C = Matrix([0, -2*L*cos(gam(t))])
D = Matrix([L*sin(gam(t)), -L*cos(gam(t))])

AB = B-A
BC = C-B
DC = C-D
AD = D-A

# Define c.g. locations
r1 = AB/2
r2 = AB + BC/2
r3 = AD + DC/2
r4 = AD/2

# acceleration of the c.g.
a1 = diff(r1,t,2)
a2 = diff(r2,t,2)
a3 = diff(r3,t,2)
a4 = diff(r4,t,2)


# Simplify the expressions to efficient symbolic manipulations later

# this part differs slightly in method of substitution
# .subs() does not work when applied to the matrix a1, a2, etc.
# instead, the components of the matrices are able to use .subs()

subStr = [(diff(gam(t),t,2), Gamdd), (diff(gam(t),t), Gamd), (gam(t), Gam)]

aa1 = Matrix([a1[0].subs(subStr), a1[1].subs(subStr)])
aa2 = Matrix([a2[0].subs(subStr), a2[1].subs(subStr)])
aa3 = Matrix([a3[0].subs(subStr), a3[1].subs(subStr)])
aa4 = Matrix([a4[0].subs(subStr), a4[1].subs(subStr)])


# Define reaction forces, spring forces, and bar weights as vectors
AA = Matrix([Ax, Ay])
BB = Matrix([Bx, By])
CC = Matrix([Cx, Cy])
DD = Matrix([Dx, Dy])
W = Matrix([0, -m*g])

# Spring forces
Fs_BD = Matrix([k*(2*L*sin(gam(t))-l0),0])
Fs_AC = Matrix([0,-k*(2*L*cos(gam(t))-l0)])
Fs_DB = -Fs_BD
Fs_CA = -Fs_AC

# Start building the equations

# this part differs slightly in structure of equations
# Each E1 is split into x and y directions rather than using vectors
# Building the matrix with linear_eq_to_matrix() was not working with vectors

Eqn1x = AA[0] + BB[0] + W[0] + Fs_BD[0] + Fs_AC[0] - m*aa1[0] # E1x for bar AB
Eqn1y = AA[1] + BB[1] + W[1] + Fs_BD[1] + Fs_AC[1] - m*aa1[1] # E1y for bar AB
Eqn2x = -BB[0] + CC[0] + W[0] + Fs_CA[0] - m*aa2[0] # E1x for bar BC
Eqn2y = -BB[1] + CC[1] + W[1] + Fs_CA[1] - m*aa2[1] # E1y for bar BC
Eqn3x = -CC[0] + DD[0] + W[0] + Fs_DB[0] - m*aa3[0] # E1x for bar CD
Eqn3y = -CC[1] + DD[1] + W[1] + Fs_DB[1] - m*aa3[1] # E1y for bar CD
# Eqn4x = -DD[0] - AA[0] + W[0] - m*aa4[0] # E1x for bar AD -- Do not need it.
# Eqn4y = -DD[1] - AA[1] + W[1] - m*aa4[1] # E1y for bar AD -- Do not need it.

# But we will use E2 for AD
exprn = (Matrix([AD[0]/2, AD[1]/2,0]).cross(Matrix([W[0], W[1],0])) +
         Matrix([AD[0], AD[1], 0]).cross(Matrix([-DD[0], -DD[1], 0])) -
         Matrix([0, 0, Izz*diff(gam(t),t,2)]))
ee = ((Transpose(Matrix([0, 0, 1])) * exprn)[0]).subs(subStr)
Eqn5z = ee

# Put all the equations together
Eqns = [Eqn1x, Eqn1y, Eqn2x, Eqn2y, Eqn3x, Eqn3y, Eqn5z]
vars = [Ax,Ay,Bx,By,Cx,Cy,Dx,Dy,Gamdd]

A, b = linear_eq_to_matrix(Eqns, vars)

# Final answers for A and b, which are identitcal to MATLAB solution
print(A)
print(b)

# Matrix A has more columns than rows. So Ax = b has infinite solutions.
# Compute the minimum norm solution

#A_inv = A.pinv()        # <-- runs infinitely, may be due to nature of matrix
#sol = A.pinv_solve(B)   # <-- runs infinitely, may be due to nature of matrix

# at this stage, we could not figure out what was going wrong
# we opted to use the matlab solution for simplified Gamdd and move on.

# MATLAB Solution

# this is what .pinv() should've given us after simplifying
numerator = -(15*Gamd**2*L**4*m**2*sin(2*Gam) - 8*L**3*g*m**2*sin(3*Gam) -
            4*Gamd**2*L**4*m**2*sin(4*Gam) + 36*L**3*g*m**2*sin(Gam) +
            5*L**3*k*l0*m*sin(Gam) -
            4*L**4*k*m*cos(3*Gam)*sin(Gam) + 2*L**4*k*m*sin(3*Gam)*cos(Gam) +
            2*L**3*k*l0*m*cos(3*Gam) - L**3*k*l0*m*sin(3*Gam) - 4*Izz*L*k*l0*cos(Gam)
            + 8*Gamd**2*Izz*L**2*m*sin(2*Gam) + 16*Izz*L*g*m*sin(Gam) +
            2*Izz*L*k*l0*sin(Gam) - 4*Izz*L**2*k*cos(Gam)*sin(Gam) +
            8*Izz*L**2*k*sin(Gam)*cos(Gam) - 10*L**4*k*m*cos(Gam)*sin(Gam) +
            6*L**4*k*m*sin(Gam)*cos(Gam) - 3*L**3*k*l0*m*cos(Gam))

denominator = (8*Izz**2 - 16*Izz*L**2*m*cos(2*Gam) + 16*Izz*L**2*m +
               8*L**4*m**2*cos(2*Gam)**2 - 23*L**4*m**2*cos(2*Gam) +
               16*L**4*m**2 + 2*L**2)

thdd_sol = numerator/denominator

# replaceing gamma with theta(t)/2
th = Function("th")
thd = diff(th(t), t)
thdd = thdd_sol.subs([(Gam, th(t)/2), (Gamd, thd/2)])

# final solution for theta double dot
print(thdd)

# Set up -----------------------------------------------------------------------

from math import radians

# Repeating Symbols from before
L, m, g, l0, k, Izz = symbols("L, m, g, l0, k, Izz")

# Given values
given = [(m, 1), (L, 1), (g, 9.806), (k, 1), (Izz, 1/3*1*1**2), (l0, 2*sin(radians(45)))]

# Plugging in given values into solution from prob 1
thdd_given = thdd.subs(given)

# print(dsolve(Eq(thdd, diff(thd, t)), th(t))) # <------- runs indefinitely

# we thought that the sines and cosines may have been the issue, so we
# plugged in taylor series expansions to replace the trig functions

# expand each sin and cosine for thdd
taylor_expand = [(sin(3*th(t)/2), (3*th(t)/2 - (3*th(t)/2)**3/factorial(3) +
                                  (3*th(t)/2)**5/factorial(5)) -
                                  (3*th(t)/2)**7/factorial(7)),
                 (sin(th(t)/2), (th(t)/2 - (th(t)/2)**3/factorial(3) +
                                (th(t)/2)**5/factorial(5)) -
                                (th(t)/2)**7/factorial(7)),
                 (sin(2*th(t)),  (2*th(t) - (2*th(t))**3/factorial(3) +
                                (2*th(t))**5/factorial(5)) -
                                (2*th(t))**7/factorial(7)),
                 (sin(th(t)),  (th(t) - (th(t))**3/factorial(3) +
                                (th(t))**5/factorial(5)) -
                                (th(t))**7/factorial(7)),
                 (cos(3*th(t)/2), (3*th(t)/2 - (3*th(t)/2)**2/factorial(2) +
                                  (3*th(t)/2)**4/factorial(4)) -
                                  (3*th(t)/2)**6/factorial(6)),
                 (cos(th(t)/2), (th(t)/2 - (th(t)/2)**2/factorial(2) +
                                (th(t)/2)**4/factorial(4)) -
                                (th(t)/2)**6/factorial(6)),
                 (cos(th(t)),  (th(t) - (th(t))**2/factorial(2) +
                               (th(t))**4/factorial(4)) -
                               (th(t))**6/factorial(6))]
# sub the expansions
thdd = thdd_given.subs(taylor_expand)

# classify_ode(Eq(thdd, diff(thd, t)), th(t)))
# dsolve(Eq(thdd, diff(thd, t)), th(t), 'factorable')) <-- runs indefinitely

# Case 1: theta(t0) = 30 deg ---------------------------------------------------

# integrate ODE w.r.t time using initial conditions

# evaluate th(t) and thd(t) over a certain time
# use matplotlib.pyplot to create plots plots

# Case 2: theta(t0) = 60 deg ---------------------------------------------------

# integrate ODE w.r.t time using initial conditions

# evaluate th(t) and thd(t) over a certain time
# use matplotlib.pyplot to create plots plots

# thd = 0 for equilibrium
# sub in 0 for thd, sub in theta for th(t)
thddeq = simplify(thdd.subs([(thd, 0), (th(t), theta)]))
print(thddeq)

# thdd = 0 for equilibruim, solve for theta
eq = Eq(thddeq, 0)
# sol = solve(eq)                     # <-- ran indefinitely

# pull thd(t) from problem 2 and thdd(t) from problem 1
# find the jacobian of the system.

# [thd(t), thdd(t)] = [matrix with partial derivatives]

# take linearized matrix from problem 4

# put in form of A - I*lambda
# find determinant and set it = 0 to solve for eigen values

# discuss stability

# using eigen values from problem 5, plot them on real and imaginary axis

# calculate nat freq using sqrt(alpha^2 + beta^2)
# calculate damping using zeta = -w/alpha

# if there is damping, analyze to find the source