# -*- coding: utf-8 -*-
"""pitch_dynamics.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10PMZDoKTT_4XxruyhYRAqPAkHHtM5sei
"""

import matplotlib.pyplot as plt
from sympy import symbols, cos, sin
from numpy import radians, linspace, array, degrees

# Angles
theta, thetad = symbols("theta, thetad")

# Geometric Properties
b = 0.3
c = 0.05
L1 = 0.15
L2 = 0.28
L3 = 0.3
S = b*c

# Inertia Propertis
M = 0.15
m = 0.3
Iyy = 1/12*M*c**2 + M*L3**2 + m*L1**2

# Free Stream Properties
U = 10
p = 1.225
q = 1/2*p*(U**2)

# Gravity
g = 9.806

# Lift Force
CN = -0.5 + 3.5*theta - 7*(theta)**2 + 4*(theta)**3 + 0.1*thetad
F2 = q*S*CN

# Gravity Forces (x components wont contribute to rotational dynamics)
F1 = -m*g*cos(theta)
F3 = -M*g*cos(theta)

# Rotational Dynamics
M = L1*F1 - L2*F2 - L3*F3
thetadd = M/Iyy

# Evaluating the Equation from theta = 0 to 60 deg
theta_vals = linspace(0, radians(60), 1000)
cm_vals = []

for th in theta_vals:
  cm = thetadd.evalf(subs={theta:th, thetad:0})
  cm_vals.append(cm)

# gettting equilibrium points
eq_points = []
cm_eq = []
for i in range(len(cm_vals) - 1):
  if (cm_vals[i] < 0 and cm_vals[i + 1] > 0):
    eq_points.append(1/2*(theta_vals[i] + theta_vals[i+1]))
    cm_eq.append(1/2*(cm_vals[i] + cm_vals[i+1]))
  elif (cm_vals[i] > 0 and cm_vals[i + 1] < 0):
    eq_points.append(1/2*(theta_vals[i] + theta_vals[i+1]))
    cm_eq.append(1/2*(cm_vals[i] + cm_vals[i+1]))

# plotting the Cm vs theta
plt.axhline(y = 0, color = 'grey', linestyle = '-')
plt.plot(degrees(theta_vals), array(cm_vals), label='C_M vs Theta')
plt.plot(degrees(array(eq_points)), array(cm_eq), 'o', color='red', label="EQ Points")
plt.title("C_M vs Theta (deg) for Theta_dot = 0")
plt.xlabel("Theta (Degrees)")
plt.ylabel("CM")
plt.legend()


# RESULTS ----------------------------------------------------------------------

# 1
print("#1\nIcm:", Iyy, "\n")

# 2
print("#2\nThetadd =", thetadd, "\n")

#3
print("#3")
plt.show()
print()

#4
print("#4 \nEQ Points (deg):", degrees(array(eq_points)))

import numpy as np

# Jacobian Solved By hand
# Inside jacobian of A, only bottom left term will change with each EQ point

# using thetadd from above, and differentiating by hand to get d(x2_dot)/d(x1)
def dx2d_dx1(theta):
  return -50.7365177195686*3*theta**2 + 88.788906009245*2*theta - 44.3944530046225

# eq points
eq_list = [14.32432432, 28.61861862, 57.26726727]

# evaluating this partial derivative at each theta eq point
# getting jacobian A for each eq point
# getting eigen values for each jacobian
A_list = []
E_list = []
for eq in eq_list:
  d = dx2d_dx1(np.radians(eq))
  A = np.matrix([[0,  1               ],
                  [d, -1.26841294298921]])
  A_list.append(A)
  E_list.append(np.linalg.eig(A)[0])

# RESULTS ----------------------------------------------------------------------
print("#5")
print()
for i in range(len(eq_list)):
  print("--- EQ point {} (theta = {}) ---".format([i+1], eq_list[i]))
  print()
  print("Linearization Matrix:")
  print(A_list[i])
  print()
  print("Eigen Values:")
  if (np.real(E_list[i][0]) < 0) and (np.real(E_list[i][1]) < 0):
    print(E_list[i], "Stable")
  else:
    print(E_list[i], "Unstable")
  print()

from numpy import array, cos, sin, linspace
from scipy.integrate import solve_ivp

def ModelDynamics(t, x):
  theta = x[0]  # x1
  thetad = x[1] # x2 = x1d

  # Geometric Properties
  b = 0.3
  c = 0.05
  L1 = 0.15
  L2 = 0.28
  L3 = 0.3
  S = b*c

  # Inertia Propertis
  M = 0.15
  m = 0.3
  Iyy = 1/12*M*c**2 + M*L3**2 + m*L1**2

  # Free Stream Properties
  U = 10
  p = 1.225
  q = 1/2*p*(U**2)

  # Gravity
  g = 9.806

  # Lift Force
  CN = -0.5 + 3.5*theta - 7*(theta)**2 + 4*(theta)**3 + 0.1*thetad
  F2 = q*S*CN

  # Gravity Forces (x components wont contribute to rotational dynamics)
  F1 = -m*g*cos(theta)
  F3 = -M*g*cos(theta)

  # Rotational Dynamics
  M = L1*F1 - L2*F2 - L3*F3
  thetadd = M/Iyy

  xd = array([thetad, thetadd]) # x1d, x2d
  return xd

import matplotlib.pyplot as plt
from numpy import degrees
def ModelSimulation(theta0, thetad0, t0, tf):
  x0 = array([theta0, thetad0])
  sol = solve_ivp(ModelDynamics, [t0, tf], x0, dense_output=True)
  t = linspace(t0, tf, 200)
  x = sol.sol(t)
  plt.title("Simulation With Theta0 = {} and Thetad0 = {}".format(theta0, thetad0))
  plt.xlabel("Time (s)")
  plt.ylabel("Theta (degrees)")
  plt.plot(t, degrees(x[0]))
  print(x[0])
  plt.show()

# Initial Condition 1
ModelSimulation(0.1, 0, 0, 10)

# Initial Condition 2
ModelSimulation(0.5, 1*(10**-4), 0, 10)

# Initial Condition 3
ModelSimulation(0, 1, 0, 10)