# -*- coding: utf-8 -*-
"""f18_dynamcis_project.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11ivHj6cq9UY1yiAwSlS4au-53NskodP4
"""

# Commented out IPython magic to ensure Python compatibility.
# clearing variables
# %reset -f

# ---- setup for problem 1 ----

# imports
from scipy.optimize import fsolve
import numpy as np

# functions
def trim_eqs(eq_values):
  # trim values
  alpha0, delta0, Fpx0 = eq_values[0], eq_values[1], eq_values[2]

  # establiting various relations for certain variables
  U0 = Vv*np.cos(alpha0)
  W0 = Vv*np.sin(alpha0)

  Cx0 = a0 + a1*alpha0 + a2*delta0**2 + a3*delta0 + a4*alpha0*delta0 + a5*alpha0**2 + a6*alpha0**3
  Cz0 = f0 + f1*alpha0 + f2*alpha0**2 + f3*alpha0**3 + f4*alpha0**4 + f5*delta0
  Cm0 = m0 + m1*alpha0 + m2*delta0 + m3*alpha0*delta0 + m4*delta0**2 + m5*alpha0**2*delta0 + m6*delta0**3 + m7*alpha0*delta0**2

  Fax0 = 1/2*p*Sw*(U0**2 + W0**2)*Cx0
  Faz0 = 1/2*p*Sw*(U0**2 + W0**2)*Cz0
  M0 = 1/2*p*Sw*cw*(U0**2 + W0**2)*(Cm0 + Cz0*(x_ref - x_cg)/cw)

  # trim equations
  trim_fx = Fax0 + Fpx0 - m*g*np.sin(alpha0)
  trim_fy = Faz0 + m*g*np.cos(alpha0)
  trim_my = M0

  # trim equations evaluated at eq values
  return [trim_fx, trim_fy, trim_my]

# ---- solving the equations -----

# given values
Vv, cw, Sw = 500, 11.32, 300
x_ref, x_cg = 0.35*cw, 0.3*cw
p, g, m = 0.002377, 32.174049, 20500/32.174049

# polynomial coefficients
a0, a1, a2, a3, a4, a5, a6 = -1.943367E-2, 2.136104E-1, -2.903457E-1, -3.348641E-3, -2.060504E-1, 6.988016E-1, -9.035381E-1
f0, f1, f2, f3, f4, f5 = -1.378278E-1, -4.211369E0, 4.775187E0, -1.026225E1, 8.399763E0, -4.354000E-1
m0, m1, m2, m3, m4, m5, m6, m7 = -2.029370E-2, 4.660702E-2, -6.012308E-1, -8.062977E-2, 8.320429E-2, 5.018538E-1, 6.378864E-1, 4.226356E-1

# solving the equations for the alpha0, delta0, Fpx0
guess = [0, 0, 1000]
trim_points = fsolve(trim_eqs, guess)
alpha0, delta0, Fpx0 = trim_points[0], trim_points[1], trim_points[2]
print("theta0:", np.degrees(alpha0))
print("alpha0:", np.degrees(alpha0))
print("delta0:", np.degrees(delta0))
print("Fpx0:", Fpx0)

# Trim Values for Cx0 and Cz0
Cx0 = a0 + a1*alpha0 + a2*delta0**2 + a3*delta0 + a4*alpha0*delta0 + a5*alpha0**2 + a6*alpha0**3
Cz0 = f0 + f1*alpha0 + f2*alpha0**2 + f3*alpha0**3 + f4*alpha0**4 + f5*delta0
Cm0 = m0 + m1*alpha0 + m2*delta0 + m3*delta0*alpha0 + m4*delta0**2 + m5*alpha0**2*delta0 + m6*delta0**3 + m7*alpha0*delta0**2 + Cz0*(x_ref-x_cg)/cw

print("Cx0:", Cx0)
print("Cz0:", Cz0)
print("Cm0:", Cm0)

# ---- setup for problem 2 ----

# imports
import sympy as sy
from IPython.display import display, Math

# ---- solving for derivatives ----

# variables
cw, x_ref, x_cg, Vv = sy.symbols("c_w, x_ref, x_cg, V_V")
alpha, delta, q = sy.symbols("alpha, delta_e, q")

# polynomial coefficients
a0, a1, a2, a3, a4, a5, a6 = sy.symbols("a_0, a_1, a_2, a_3, a_4, a_5, a_6")
b0, b1, b2, b3, b4, b5 = sy.symbols("b_0, b_1, b_2, b_3, b_4, b_5")
f0, f1, f2, f3, f4, f5 = sy.symbols("f_0, f_1, f_2, f_3, f_4, f_5")
g0, g1, g2, g3, g4 = sy.symbols("g_0, g_1, g_2 , g_3, g_4")
m0, m1, m2, m3, m4, m5, m6, m7 = sy.symbols("m_0, m_1, m_2, m_3, m_4, m_5, m_6, m_7")
n0, n1, n2, n3, n4, n5 = sy.symbols("n_0, n_1, n_2, n_3, n_4, n_5")

# setting given values
numerical = True
if numerical:
  # given values
  Vv, cw = 500, 11.32
  x_ref, x_cg = 0.35*cw, 0.3*cw

  # polynomial coefficients
  a0, a1, a2, a3, a4, a5, a6 = -1.943367E-2, 2.136104E-1, -2.903457E-1, -3.348641E-3, -2.060504E-1, 6.988016E-1, -9.035381E-1
  b0, b1, b2, b3, b4 = 4.833383e-01, 8.644627e+00, 1.131098e+01, -7.422961e+01, 6.075776e+01
  f0, f1, f2, f3, f4, f5 = -1.378278E-1, -4.211369E0, 4.775187E0, -1.026225E1, 8.399763E0, -4.354000E-1
  g0, g1, g2, g3, g4 = -3.054956e+01, -4.132305e+01, 3.292788e+02, -6.848038e+02, 4.080244e+02
  m0, m1, m2, m3, m4, m5, m6, m7 = -2.029370E-2, 4.660702E-2, -6.012308E-1, -8.062977E-2, 8.320429E-2, 5.018538E-1, 6.378864E-1, 4.226356E-1
  n0, n1, n2, n3, n4, n5 = -5.159153e+00, -3.554716e+00, -3.598636e+01, 2.247355e+02, -4.120991e+02, 2.411750e+02

# coefficient equations
q_bar = q*cw/(2*Vv)

Cx_ad = a0 + a1*alpha + a2*delta**2 + a3*delta + a4*alpha*delta +a5*alpha**2 + a6*alpha**3
Cxq_a = b0 + b1*alpha + b2*alpha**2 + b3*alpha**3 + b4*alpha**4
Cx = Cx_ad + Cxq_a*q_bar

Cz_abe = f0 + f1*alpha + f2*alpha**2 + f3*alpha**3 + f4*alpha**4 + f5*delta
Czq_a = g0 + g1*alpha + g2*alpha**2 + g3*alpha**3 + g4*alpha**4
Cz = Cz_abe + Czq_a*q_bar

Cm_ae = m0 + m1*alpha + m2*delta + m3*alpha*delta + m4*delta**2 + m5*alpha**2*delta + m6*delta**3 + m7*alpha*delta**2
Cmq_a = n0 + n1*alpha + n2*alpha**2 + n3*alpha**3 + n4*alpha**4 + n5*alpha**5
Cm = Cm_ae + Cmq_a*q_bar + Cz*(x_ref - x_cg)/cw

# derivatives of coefficient equations:

C_Xa = sy.diff(Cx, alpha)
C_Xd = sy.diff(Cx, delta)
C_Xq = sy.diff(Cx, q)

C_Za = sy.diff(Cz, alpha)
C_Zd = sy.diff(Cz, delta)
C_Zq = sy.diff(Cz, q)

C_Ma = sy.diff(Cm, alpha)
C_Md = sy.diff(Cm, delta)
C_Mq = sy.diff(Cm, q)

print("Cx:")
display(Cx)
print()
print("Cz:")
display(Cz)
print()
print("Cm:")
display(Cm)
print()
print("C_Xa:")
display(C_Xa)
print()
print("C_Xd:")
display(C_Xd)
print()
print("C_Xq:")
display(C_Xq)
print()
print("C_Za:")
display(C_Za)
print()
print("C_Zd:")
display(C_Zd)
print()
print("C_Zq:")
display(C_Zq)
print()
print("C_Ma:")
display(C_Ma)
print()
print("C_Md:")
display(C_Md)
print()
print("C_Mq:")
display(C_Mq)
print()

# Cq tildes
display(C_Xq/(cw/(2*Vv)))
display(C_Zq/(cw/(2*Vv)))
display(C_Mq/(cw/(2*Vv)))

subs = [(alpha, alpha0), (delta, delta0), (q, 0)]

Cx_0 = Cx.subs(subs)
Cz_0 = Cz.subs(subs)
Cm_0 = Cm.subs(subs)

C_Xa0 = C_Xa.subs(subs)
C_Xd0 = C_Xd.subs(subs)
C_Xq0 = C_Xq.subs(subs)

C_Za0 = C_Za.subs(subs)
C_Zd0 = C_Zd.subs(subs)
C_Zq0 = C_Zq.subs(subs)

C_Ma0 = C_Ma.subs(subs)
C_Md0 = C_Md.subs(subs)
C_Mq0 = C_Mq.subs(subs)

Vv0 = 500
print("Cx_0:")
display(Cx_0)
print()
print("Cz_0:")
display(Cz_0)
print()
print("Cm_0:")
display(Cm_0)
print()
print("C_Xa0:")
display(C_Xa0)
print()
print("C_Xd0:")
display(C_Xd0)
print()
print("C_Xq0:")
display(C_Xq0/(cw/(2*Vv0)))
print()
print("C_Za0:")
display(C_Za0)
print()
print("C_Zd0:")
display(C_Zd0)
print()
print("C_Zq0:")
display(C_Zq0/(cw/(2*Vv0)))
print()
print("C_Ma0:")
display(C_Ma0)
print()
print("C_Md0:")
display(C_Md0)
print()
print("C_Mq0:")
display(C_Mq0/(cw/(2*Vv0)))
print()

m, p, Sw, U, W, Vv, alpha, cw, Iyy = sy.symbols("m, rho, S_w, U, W, V_V, alpha, c_w, I_yy")

# --- PARTIALS WRT U ----
subs = [(alpha, alpha0), (delta, delta0), (q, 0), (Sw, 300), (p, 0.002377), (U, 500*np.cos(alpha0)), (m, 20500/32.174049), (cw, 11.32), (Iyy, 55814)]

X = 1/(2*m)*p*Sw*(U**2 + W**2)*Cx
Z = 1/(2*m)*p*Sw*(U**2 + W**2)*Cz
M  = 1/(2*Iyy)*p*Sw*(U**2 + W**2)*Cm*cw

# exact u partials
Xu = sy.diff(X, U).subs(subs)
Zu = sy.diff(Z, U).subs(subs)
Mu = sy.diff(M, U).subs(subs)

print("Exact Xu, Zu, Mu:")
display(Xu)
display(Zu)
display(Mu)
print()

# ---- PARTIALS WRT Q ----
subs = [(alpha, alpha0), (delta, delta0), (q, 0), (Sw, 300), (p, 0.002377), (Vv, 500), (m, 20500/32.174049), (cw, 11.32), (Iyy, 55814)]

X = 1/(2*m)*p*Sw*(Vv**2)*Cx
Z = 1/(2*m)*p*Sw*(Vv**2)*Cz
M  = 1/(2*Iyy)*p*Sw*(Vv**2)*Cm*cw

# exact q partials
Xq = sy.diff(X, q).subs(subs)
Zq = sy.diff(Z, q).subs(subs)
Mq = sy.diff(M, q).subs(subs)
print("Exact Xq, Zq, Mq:")
display(Xq)
display(Zq)
display(Mq)
print()

# ---- PARTIALS WRT DELTA ----

# exact q partials
Xd = sy.diff(X, delta).subs(subs)
Zd = sy.diff(Z, delta).subs(subs)
Md = sy.diff(M, delta).subs(subs)
print("Exact Xd, Zd, Md")
display(Xd)
display(Zd)
display(Md)
print()

# ---- PARTIALS WRT ALPHA ----
subs = [(alpha, alpha0), (delta, delta0), (q, 0), (Sw, 300), (p, 0.002377), (Vv, 500), (m, 20500/32.174049), (cw, 11.32), (Iyy, 55814)]
U, W, = Vv*sy.cos(alpha), Vv*sy.sin(alpha)

# approx q partials
Xa = (1/(2*m)*p*Sw*(2*W*Vv**2/U*Cx + Vv**2*C_Xa)).subs(subs)
Za = (1/(2*m)*p*Sw*(2*W*Vv**2/U*Cz + Vv**2*C_Za)).subs(subs)
Ma = (1/(2*Iyy)*p*Sw*(2*W*Vv**2/U*Cm + Vv**2*C_Ma)*cw).subs(subs)
print("Approx Xa, Za, Ma:")
display(Xa)
display(Za)
display(Ma)
print()

import numpy as np
Vv0 = 500
U0 = 500*np.cos(alpha0)
cw = 11.32

A = sy.Matrix([[Xu, Xa, Xq - Vv0*np.sin(alpha0), -g*np.cos(alpha0)],
               [Zu/U0, Za/U0, (Zq + Vv0*np.cos(alpha0))/U0, -g*np.sin(alpha0)/U0],
               [Mu, Ma, Mq, 0],
               [0, 0, 1, 0]])

B = sy.Matrix([[Xd],
               [Zd/U0],
               [Md],
               [0]])

print("A:")
display(A)
print()
print("B:")
display(B)

# simplified model

A_simple = A[1:3, 1:3]
A_simple[0, 0] = 0
A_simple[0, 1] = 1

print("A:")
display(A_simple)
print()

ev = A_simple.eigenvects()
display(ev[0][0])
display(ev[1][0])
print()

eigenval = list(ev[0][0].as_real_imag())
eigenval[0] = float(eigenval[0])
eigenval[1] = float(eigenval[1])

w_n = np.sqrt(eigenval[0]**2 + eigenval[1]**2)
zeta = eigenval[0]/w_n
w = w_n*np.sqrt(1 - zeta**2)
t_half = np.log(2)/abs(eigenval[0])
t_constant = 1/abs(eigenval[0])

display(w_n)
display(zeta)
display(w)
display(t_half)
display(t_constant)
print()

# b) normal model

W0 = Vv0*np.sin(alpha0)

print("A:")
A = sy.Matrix([[Xu, Xa, Xq - Vv0*np.sin(alpha0), -g*np.cos(alpha0)],
               [Zu/U0, Za/U0, (Zq + Vv0*np.cos(alpha0))/U0, -g*np.sin(alpha0)/U0],
               [Mu, Ma, Mq, 0],
               [0, 0, 1, 0]])

print()

display(A)
print()

ev = A.eigenvects()

# eigen values
eval1 = ev[0][0]
eval2 = ev[1][0]
eval3 = ev[2][0]
eval4 = ev[3][0]

display(eval1)
display(eval2)
display(eval3)
display(eval4)
print()

eigenval = list(eval1.as_real_imag())
eigenval[0] = float(eigenval[0])
eigenval[1] = float(eigenval[1])

w_n = np.sqrt(eigenval[0]**2 + eigenval[1]**2)
zeta = eigenval[0]/w_n
w = w_n*np.sqrt(1 - zeta**2)
t_half = np.log(2)/abs(eigenval[0])
t_constant = 1/abs(eigenval[0])

print()
display(w_n)
display(zeta)
display(w)
display(t_half)
display(t_constant)
print()

eigenval = list(eval4.as_real_imag())
eigenval[0] = float(eigenval[0])
eigenval[1] = float(eigenval[1])

w_n = np.sqrt(eigenval[0]**2 + eigenval[1]**2)
zeta = eigenval[0]/w_n
w = w_n*np.sqrt(1 - zeta**2)
t_half = np.log(2)/abs(eigenval[0])
t_constant = 1/abs(eigenval[0])

display(w_n)
display(zeta)
display(w)
display(t_half)
display(t_constant)

Anp = np.matrix([[float(Xu), float(Xa), float(Xq - Vv0*np.sin(alpha0)), float(-g*np.cos(alpha0))],
               [float(Zu/U0), float(Za/U0), float((Zq + Vv0*np.cos(alpha0))/U0), float(-g*np.sin(alpha0)/U0)],
               [float(Mu), float(Ma), float(Mq), 0],
               [0, 0, 1, 0]])

ev = np.linalg.eig(Anp)

print(ev)

# a) short period 2x2

A_short = A[1:3, 1:3]

print("A:")
display(A_short)
print()

ev = A_short.eigenvects()

display(ev[1][0])
display(ev[0][0])
print()

eigenval = list(ev[1][0].as_real_imag())
eigenval[0] = float(eigenval[0])
eigenval[1] = float(eigenval[1])

w_n = np.sqrt(eigenval[0]**2 + eigenval[1]**2)
zeta = eigenval[0]/w_n
w = w_n*np.sqrt(1 - zeta**2)
t_half = np.log(2)/abs(eigenval[0])
t_constant = 1/abs(eigenval[0])

display(w_n)
display(zeta)
display(w)
display(t_half)
display(t_constant)

A_shortnp = Anp[1:3, 1:3]

ev = np.linalg.eig(A_shortnp)

print(ev)

# a) phugoid 2x2

A_fugoid = sy.Matrix([[A[0, 0], A[0, 3]],
                      [-A[1, 0], -A[1, 3]]])

print("A:")
display(A_fugoid)
print()

ev = A_fugoid.eigenvects()
display(ev[1][0])
display(ev[0][0])
print()

eigenval = list(ev[1][0].as_real_imag())
eigenval[0] = float(eigenval[0])
eigenval[1] = float(eigenval[1])

print("HEY",eigenval[0] )
w_n = np.sqrt(eigenval[0]**2 + eigenval[1]**2)
zeta = eigenval[0]/w_n
w = w_n*np.sqrt(1 - zeta**2)
t_half = np.log(2)/abs(eigenval[0])
t_constant = 1/abs(eigenval[0])

display(w_n)
display(zeta)
display(w)
display(t_half)
display(t_constant)

A_fugoid = np.matrix([[float(A[0, 0]), float(A[0, 3])],
                      [float(-A[1, 0]), float(-A[1, 3])]])

ev = np.linalg.eig(A_fugoid)

print(ev)