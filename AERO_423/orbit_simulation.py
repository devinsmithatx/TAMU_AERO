# -*- coding: utf-8 -*-
"""orbit_simulation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19QTkY-nC9VPf5XfwaarCjx0UDI9RJhnb
"""

# problem 1

# ---- imports ----
import numpy as np
from scipy.integrate import solve_ivp
import matplotlib.pyplot as plt

# ---- functions ----

def ModelDynamics(t, s):
  # input state space vector (SSV) and time; returns the derivative of SSV
  # s = SSV (in array form)= [x, y, z, dx, dy, dz]
  # ds = dSSV (in array form)= [dx, dy, dz, ddx, ddy, ddz]

  x, y, z = s[0], s[1], s[2]
  dx, dy, dz = s[3], s[4], s[5]

  # solving for r1 and r2 [not constant]
  r1_v = np.array([x - x1, y, z])
  r2_v = np.array([x - x2, y ,z])

  # maginude of r1 and r2
  r1 = np.linalg.norm(r1_v)
  r2 = np.linalg.norm(r2_v)

  # A matrix and B vector that defines dynamics
  num = -(u1/r1**3 + u2/r2**3)
  A = np.matrix([[0, 0, 0, 1, 0, 0],
                 [0, 0, 0, 0, 1, 0],
                 [0, 0, 0, 0, 0, 1],
                 [num + w**2, 0, 0, 2*w, 0, 0],
                 [0, num + w**2, 0, 0, -2*w, 0],
                 [0, 0, num, 0, num, 0]])

  B = np.matrix([[0],
                 [0],
                 [0],
                 [-(u1*m2/r1**3 - u2*m1/r2**3)*r12/(m1 + m2)],
                 [0],
                 [0]])

  # p is state space vector (in matrix form, different name to avoid confusion)
  p = np.matrix([[s[0]],
                 [s[1]],
                 [s[2]],
                 [s[3]],
                 [s[4]],
                 [s[5]]])

  # q is derivative of state space vector (in matrix form, different name)
  q = A*p + B

  # ds is derivative of state space vector (in array form)
  ds = np.array([q[0, 0], q[1, 0], q[2, 0], q[3, 0], q[4, 0], q[5, 0]])
  return ds


def ModelSimulation(s0):
  # takes in an initial condition of x,y,z,dx,dy,dz and plots them

  # time interval chosen to be long
  t0, tf = 0, 24*3600

  # solve dynamics
  sol = solve_ivp(ModelDynamics, [t0, tf], s0, dense_output=True, method='RK45')
  t = np.linspace(t0, tf, 200)

  # r is the values of x,y,z,dx,dy,dz over the whole interval
  r = sol.sol(t)

  # solutions for each x,y,z,dx,dy,dz over time
  xs, ys, zs= r[0], r[1], r[2]
  dxs, dys, dzs= r[3], r[4], r[5]

  # plotting position trajectories
  plt.plot(t, xs, label="x-position")
  plt.plot(t, ys, label='y-position')
  plt.plot(t, zs, label='z-position')
  plt.xlabel("time (s)")
  plt.ylabel("position (km)")
  plt.title("position vs time for dy/dt(0) = {}".format(s0[4]))
  plt.legend()
  plt.show()

  # plotting velocity trajectories
  # plt.plot(t, dxs, label='x-velocity')
  # plt.plot(t, dys, label='y-velocity')
  # plt.plot(t, dzs, label='z-velocity')
  # plt.xlabel("time (s)")
  # plt.ylabel("velocity (km/s)")
  # plt.title("velocity vs time for dy/dt(0) = {}".format(s0[4]))
  # plt.legend()
  plt.show()


# ---- Constant Global Values ----

# given values
w = 2.662E-6
u1 = 398600.44
u2 = 4904.87
r12 = 384748

# not given but assumed
G = 6.6743E-20

# solving for x1 and x2
m1 = u1/G
m2 = u2/G

print(m1)
print(m2)

x1 = -m2/(m1 + m2)*r12
x2 = m1/(m1 + m2)*r12

print(x1)
print(x2)

# ---- Solving Different Initial Conditions ----

# set of y0 values to be varied
dy0_vals = np.arange(-3, 0.5, 0.5)
# initial conditions that do not change
x0, y0, z0, dx0, dz0 = 1.05*x2, 0, 0, 0, 0.05

# simulating for each set of initial conditions
for dy0 in dy0_vals:
  print(dy0)
  ModelSimulation(np.array([x0, y0, z0, dx0, dy0, dz0]))

# Number 2

# ---- imports ----
import numpy as np
import sympy as sp

# ---- functions ----

def J0(y, m, d):
  return 367*y - int(7/4*(y + int((m + 9)/12))) + int(275/9*m) + d + 1721013.5

def T0(J0):
  return (J0 - 2451545)/36525

def thG0(T0):
  num = 100.4606184 + 36000.77004*T0 + 0.000387933*T0**2 - 2.583*10**-8*T0*3
  if num > 360:
    remainder = num%360
    return remainder

def thG(UT):
  num = thG0 + 360.98564724*UT/24
  if num > 360:
    remainder = num%360
    return remainder

def R(th, phi, H):
  Re = 6378
  f = 0.003353
  num = Re/np.sqrt(2 - (2*f - f**2)*np.sin(np.radians(phi))**2) + H

  x = num*np.cos(np.radians(phi))*np.cos(np.radians(th))
  y = num*np.cos(np.radians(phi))*np.sin(np.radians(th))
  z = num*np.sin(np.radians(phi))

  return np.array([x, y, z])

def rho_hat(a, A, th, phi):
  xx = np.cos(np.radians(a))*np.sin(np.radians(A))
  yx = np.cos(np.radians(a))*np.cos(np.radians(A))
  zx = np.sin(np.radians(a))

  tr = np.radians(th)
  pr = np.radians(phi)

  rho_x = np.matrix([[xx],
                     [yx],
                     [zx]])

  Q = np.matrix([[-np.sin(tr), -np.sin(pr)*np.cos(tr), np.cos(pr)*np.cos(tr)],
                  [np.cos(tr), -np.sin(pr)*np.sin(tr), np.cos(pr)*np.sin(tr)],
                  [0, np.cos(pr), np.sin(pr)]])

  rho_X = Q*rho_x

  xX, yX, zX = rho_X[0, 0], rho_X[1, 0], rho_X[2, 0]

  return np.array([xX, yX, zX])

# ---- solving problem ----

# given properties of college station
latitude_N = 30.6280
longitude_E = 360 - 96.3344
altitude = 0.0881
u = 398600.44

a1 = 26
a2 = 68
a3 = 10

A1 = 224
A2 = 147
A3 = 64

UT1 = 12 + 5/60 + 13/3600
UT2 = 12 + 6/60 + 45/3600
UT3 = 12 + 9/60 + 50/3600

# calculating local sidereal times
J0 = J0(2023, 4, 7)
T0 = T0(J0)
thG0 = thG0(T0)

thG1 = thG(UT1)
thG2 = thG(UT2)
thG3 = thG(UT3)

th1 = thG1 + longitude_E
th2 = thG2 + longitude_E
th3 = thG3 + longitude_E

# calculating R of observer for each time
R1 = R(th1, latitude_N, altitude)
R2 = R(th2, latitude_N, altitude)
R3 = R(th3, latitude_N, altitude)

# calculating p from observer for each time
rho1_h = rho_hat(a1, A1, th1, latitude_N)
rho2_h = rho_hat(a2, A2, th2, latitude_N)
rho3_h = rho_hat(a3, A3, th3, latitude_N)

# printint out results so far
print("J0:", J0)
print("T0:", T0)
print("thG0:", thG0)
print()
print("UT1:", UT1)
print("UT2:", UT2)
print("UT3:", UT3)
print()
print("thG1:", thG1)
print("thG2:", thG2)
print("thG3:", thG3)
print()
print("th1:", th1)
print("th2:", th2)
print("th3:", th3)
print()
print("R1:", R1)
print("R2:", R2)
print("R3:", R3)
print()
print("rho1_hat:", rho1_h)
print("rho2_hat:", rho2_h)
print("rho3_hat:", rho3_h)

# Gauss's Method

# ---- Step 1 ----

# calculate tau's
t1 = UT1 * 3600
t2 = UT2 * 3600
t3 = UT3 * 3600

tau1 = t1 - t2
tau3 = t3 - t2
tau = tau3 - tau1

print("tau1:", tau1)
print("tau2:", tau3)
print("tau:", tau)
print()

# ---- Step 2 ----

# calculate p vectors
p1 = np.cross(rho2_h, rho3_h)
p2 = np.cross(rho1_h, rho3_h)
p3 = np.cross(rho1_h, rho2_h)

print("p1:", p1)
print("p2:", p2)
print("p3:", p3)
print()

# ---- Step 3 ----

# calculate D0
D0 = np.dot(rho1_h, p1)

print("D0:", D0)
print()


# ---- Step 4 ----

# calculate each Dij coefficient

D11 = np.dot(R1, p1)
D21 = np.dot(R2, p1)
D31 = np.dot(R3, p1)

D12 = np.dot(R1, p2)
D22 = np.dot(R2, p2)
D32 = np.dot(R3, p2)

D13 = np.dot(R1, p3)
D23 = np.dot(R2, p3)
D33 = np.dot(R3, p3)

D = np.matrix([[D11, D12, D13],
               [D21, D22, D23],
               [D31, D32, D33]])

print("D:", D)
print()

# ---- Step 5 ----

# calculate A and B
A = 1/D0 * (-D12 * tau3/tau + D22 + D32*tau1/tau)
B = 1/(6*D0)*(D12*(tau3**2-tau**2)*tau3/tau+D32*(tau**2-tau1**2)*tau1/tau)

print("A:", A)
print("B:", B)
print()

# ---- Step 6 ----

# calculate E and R2**2
E = np.dot(R2, rho2_h)
R2_2 = np.dot(R2, R2)

print("E:", E)
print("R2**2:", R2_2)
print()

# ---- Step 7 ----

# calculate a, b, and c
a = -(A**2 + 2*A*E + R2_2)
b = -2*u*B*(A+E)
c = -u**2 * B**2

print("a:", a)
print("b:", b)
print("c:", c)
print()

# ---- Step 8 ----

# find roots of Eq

x = 140000
for i in range(0, 50):
  x_1 = x - (x**8 + a*x**6 + b*x**3 + c)/(8*x**7 + 6*a*x**5 + 3*b*x**2)
  x = x_1

print("r2:", x)
print()

# ---- Step 9 ----

# calculate rho1, rho2, rho3

numerator1 = 6*(D31*tau1/tau3+D21*tau/tau3)*x**3+u*D31*(tau**2-tau1**2)*tau1/tau3
denominator1 = 6*x**3 + u*(tau**2 - tau3**2)

numerator3 = 6*(D13*tau3/tau1-D23*tau/tau1)*x**3+u*D13*(tau**2-tau3**2)*tau3/tau1
denominator3 = 6*x**3 + u*(tau**2 - tau1**2)

rho1 = 1/D0 * (numerator1/denominator1 - D11)
rho2 = A + u*B/x**3
rho3 = 1/D0 * (numerator3/denominator3 - D33)

print("rho1:", rho1)
print("rho2:", rho2)
print("rho3:", rho3)
print()

# ---- Steo 10 ----

# calculate r1, r2, r3
r1 = R1 + rho1*rho1_h
r2 = R2 + rho2*rho2_h
r3 = R3 + rho3*rho3_h

print("r1:", r1)
print("r2:", r2)
print("r3:", r3)
print()

# ---- Step 11 ----

# calculate f1, g1, f3, g3

f1 = 1 - 1/2*u/x**3 * tau1**2
f3 = 1 - 1/2*u/x**3 * tau3**2
g1 = tau1 - 1/6*u/x**3 * tau1**3
g3 = tau3 - 1/6*u/x**3 * tau3**3

print("f1:", f1)
print("f3:", f3)
print("g1:", g1)
print("g3:", g3)
print()

# ---- Step 12 ----

# calculate v2

v2 = 1/(f1*g3 - f3*g1) * (-f3*r1 + f1*r3)

print("v2:", v2)

# Calculating Orbital Elements from V2 and R2

# ---- Step 1 and 2 ----

r = np.sqrt(np.dot(r2, r2))
v = np.sqrt(np.dot(v2, v2))

# ---- Step 3 ----

vr = np.dot(r2, v2/r)

# ---- Step 4 and 5 ----

h = np.cross(r2, v2)
h_mag = np.sqrt(np.dot(h, h))

# ---- Step 6 ----

i = np.arccos(h[2]/h_mag)

# ---- Step 7 and 8 ----

k = np.array([0, 0, 1])
N = np.cross(k, h)
N_mag = np.sqrt(np.dot(N, N))

# ---- Step 9 ----

if N[1] >= 0:
  om = np.arccos(N[0]/N_mag)
else:
  om = 2*np.pi - np.arccos(N[0]/N_mag)

# ---- Step 10 and 11 ----

e = 1/u*((v**2 - u/r)*r2 - r*vr*v2)
e_mag = np.sqrt(np.dot(e, e))

# ---- Step 12 ----

if e[2] >= 0:
  w = np.arccos(np.dot(N/N_mag, e/e_mag))
else:
  w = 2*np.pi - np.arccos(np.dot(N/N_mag, e/e_mag))

# ---- Step 13 ----

if vr >= 0:
  th = np.arccos(np.dot(r2/r, e/e_mag))
else:
  th = 2*np.pi - np.arccos(np.dot(r2/r, e/e_mag))

# ---- Step 14 ----

a = u/(2*u/r - v**2)

print("r:", r)
print("v:", v)
print("vr:", vr)
print("h:", h)
print("h_mag:", h_mag)
print("K_hat:", k)
print("N:", N)
print("N_mag:", N_mag)
print("e:", e)
print()
print("a:", a)
print("e_mag:", e_mag)
print("i:", np.degrees(i))
print("omega:", np.degrees(om))
print("w:", np.degrees(w))
print("th:", np.degrees(th))