# -*- coding: utf-8 -*-
"""orbit_determination.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1GKBtnz3EweU7x2FqWt1OXthFWPB5zO59
"""

from math import cos, pi, acos, cos, sin, degrees, radians, sqrt

u = 398600.493
re = 6371
rp = 6800
i = radians(28)

# 1
ra = 42186

# 2
e = (ra - rp)/(ra + rp)

# 3
a = rp/(1 - e)

# 4
T = sqrt(4*pi**2/u*a**3)/3600

# 5
E = -u/(2*a)

# 6
p = a*(1 - e**2)
r = re + 1000
psi  = acos((p - r)/(r*e))

# 7
h = sqrt(u*p)
vt = u/h*(1 + e*cos(psi))
vr = u/h*(e*sin(psi))

# 8
vp = sqrt(2*(E + u/rp))
va = sqrt(2*(E + u/ra))

# 9
v1 = sqrt(u/rp)
v2 = sqrt(u/ra)

dv1 = vp - v1
dv2 = sqrt(v2**2 + va**2 - 2*v2*va*cos(i))
dv = abs(dv1) + abs(dv2)

from math import radians, degrees, tan, sin, cos, asin, sqrt
from numpy import matrix

# ---- givens -----

# given distances
ap = 215
aa = 939

# given velocity
v = 3.5

# given times
tp = 295.4
t0 = 0

# launch latitude, longitude, inclination
l_l = radians(45.92)
lam_l = radians(63.34)
i = radians(65.1)

# angular velicity of earth and radius of earth + gravitational constant
w = 72.921159E-6
re = 6378
u = 398600.441

# ---- calculations ----

# delta
delt = asin(tan(l_l)/tan(i))

# initial greenwich angle
ag0 = -w*(tp-t0)

# right acsension of acsending node
om = ag0 + lam_l - delt

# argument of perigee portion due to given ground velocity and time to perigee
d = v*tp
wp = d/re

# argument of perigee portion due to given launch sight
wl = asin(sin(l_l)/sin(i))

# total agument of perigee
w = wp + wl

# latitude of perigee
l_p = asin(sin(i)*sin(w))

# longitude of perigee
lam_p = asin(tan(l_p)/tan(i)) + om - ag0

print(degrees(om))
print(degrees(w))
print(degrees(l_p), degrees(lam_p))

# eccentricity
rp = ap + re
ra = aa + re
e = (ra - rp)/(rp + ra)

# semimajor axis
a = rp/(1 - e)

# total energy
E = -u/(2*a)

# velocity at perigee
vp = sqrt(2*(E + u/rp))

# DCM
C_OI = matrix([[cos(om)*cos(w)-sin(om)*sin(w)*cos(i), sin(om)*cos(w)+cos(om)*sin(w)*cos(i), sin(w)*sin(i)],
               [-cos(om)*sin(w)-sin(om)*cos(w)*cos(i), -sin(om)*sin(w)+cos(om)*cos(w)*cos(i), cos(w)*sin(i)],
               [sin(om)*sin(i), -cos(om)*sin(i), cos(i)]])

# orbital coords for vp and rp
vp_o = matrix([[0],
               [vp],
               [0]])
rp_o = matrix([[rp],
               [0],
               [0]])

# inertial coords for vp and rp
vp_i = C_OI.T*vp_o
rp_i = C_OI.T*rp_o

print(C_OI)
print(vp_i)
print(rp_i)

# solving for angular momentum
vpm = sqrt(vp_i[0, 0]**2 + vp_i[1, 0]**2 + vp_i[2, 0]**2)
rpm = sqrt(rp_i[0, 0]**2 + rp_i[1, 0]**2 + rp_i[2, 0]**2)
h = rpm*vpm
print(h)

from math import pi

# givens
t = 50*60
t0 = 295.5

# T, n, and M can be solved from earlier part of problem
T = sqrt(4*pi**2/u*a**3)
n = 2*pi/T
M = n*(t - t0)

print(T, M)

# functions for Halley's Method
def f(x):
  return E[k] - e*sin(E[k]) - M

def df(x):
  return 1 - e*cos(E[k])

def ddf(x):
  return e*sin(E[k])

# tolerance
tol = 1E-15

# iterations of E
E = []
E.append(M - e/2)

# halleys method
k = 0
E_k_1 = E[k] - (2*f(E[k])*df(E[k]))/(2*df(E[k])**2 - f(E[k])*ddf(E[k]))
E.append(E_k_1)
while abs(E[k + 1] - E[k]) > tol:
  k += 1
  E_k_1 = E[k] - (2*f(E[k])*df(E[k]))/(2*df(E[k])**2 - f(E[k])*ddf(E[k]))
  E.append(E_k_1)

print(E[-1])
print(degrees(E[-1]))

# getting true anomaly from eccentric anomaly

phi = acos(cos((E[-1])-e)/(1 - e*cos(E[-1])))

print(phi)
print(degrees(phi))