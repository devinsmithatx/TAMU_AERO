# -*- coding: utf-8 -*-
"""AERO423_HW5.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1LMcjp1_57G7iGg5hfW3rt1UaXV11Gdg9
"""

# problem 1

# imports
from numpy import cos, sin, sqrt, radians, degrees, pi

# givens
Re = 6_378.135
u = 398_600.4415
J2 = 1.082645E-3

rp = 300 + Re
ra = 450 + Re
i = radians(55)

# calculations

e = (ra - rp)/(ra + rp)
a = rp/(1 - e)
p = a*(1 - e**2)
T0 = sqrt((2*pi)**2 /u * a**3)
n0 = 2*pi/T0

n = n0*(1 + 3/4*J2*(Re/p)**2*(2-3*sin(i)**2)*sqrt(1-e**2))
dOm = -(3*J2*Re**2)/2*n/p**2*cos(i)
dw = (3*J2*Re**2)/4*n/p**2*(5*cos(i)**2 - 1)

# output

print("rp:", rp)
print("ra:", ra)
print("e:", e)
print("a:", a)
print("p:", p)
print("T0:", T0)
print("n0:", n0)
print()
print("n:", n)
print("dOm/dt:", degrees(dOm))
print("dw/dt:", degrees(dw))
print()

print(3*J2*Re**2*(4-sin(i)**2))

# imports

from sympy import sin, cos, symbols, pi, diff, sqrt
from IPython.display import display_html

# symbols

n0_s, J2_s, Re_s, i_s, w_s, a_s, e_s = symbols("n_0, J_2 R_E, i, omega, a, e")

# --- symbolic eqs ----

Ta_numerator = 3*J2_s*Re_s**2*(1 - 3*sin(i_s)**2 * sin(w_s)**2)
Ta_denominator = 2*a_s**2 * (1 - e_s**2)**3
Ta = 2*pi/n0_s*(1 - Ta_numerator/Ta_denominator)

Tn_numerator1 = 3*J2_s*Re_s**2*(4 - 5*sin(i_s)**2)
Tn_denominator1 = 4*a_s**2*sqrt(1-e_s**2)*(1+e_s*cos(w_s))**2
Tn_numerator2 = 3*J2_s*Re_s*(1 + e_s*cos(w_s))**3
Tn_denominator2 = 2*a_s**2*(1-e_s**2)**3
Tn = 2*pi/n0_s*(1 - Tn_numerator1/Tn_denominator1 - Tn_numerator2/Tn_denominator2)

print("Ta:")
display(Ta)
print()
print("Tn:")
display(Tn)

# ---- numerical ----

Ta_numerator = 3*J2*Re**2*(1 - 3*sin(i)**2 * sin(w_s)**2)
Ta_denominator = 2*a**2 * (1 - e**2)**3
Ta = 2*pi/n0*(1 - Ta_numerator/Ta_denominator)

Tn_numerator1 = 3*J2*Re**2*(4 - 5*sin(i)**2)
Tn_denominator1 = 4*a**2*sqrt(1-e**2)*(1+e*cos(w_s))**2
Tn_numerator2 = 3*J2*Re*(1 + e*cos(w_s))**3
Tn_denominator2 = 2*a**2*(1-e**2)**3
Tn = 2*pi/n0*(1 - Tn_numerator1/Tn_denominator1 - Tn_numerator2/Tn_denominator2)

print()
print("Ta:")
Ta = Ta.simplify()/pi*3.14159265359
display(Ta)

print()
print("Tn:")
display(Tn/pi*3.14159265359)

# imports
from numpy import cos, sin, sqrt, radians, degrees, pi, exp

# givens
Re = 6_378.135
u = 398_600.4415
J2 = 1.082645E-3

i = radians(33.5)
om = radians(125.5)
w = radians(270.7)
M = radians(123.234)

e = 0.2
a = 10000

g = 9.81
Isp = 200

# calculations

p = a*(1 - e**2)
dv = -(e*sqrt(u/p))*(3*pi*J2/2)*(Re/p)**2 * (5*cos(i)**2 - 1)
T = sqrt((2*pi)**2/u*a**3)
orbits = 365.25*60*60*24/T
dvy = orbits*dv

dm = 1 - exp(dvy*1000/g/Isp)

# output

print("p", p)
print("dv", dv)
print("T", T)
print("orbits/year:", orbits)
print("dv_year:", dvy)

print(dm)

# imports

from numpy import matrix, cos, sin, sqrt, arccos, degrees, trace, pi
from numpy.linalg import norm

# givens

q = matrix([[0.0485],
            [0.5932],
            [0.3781],
            [0.7091]])

phi = 1.5521
e = matrix([[0.0769],
            [0.8436],
            [0.5314]])

p = matrix([[0.0769],
            [0.8311],
            [0.5507]])

r = matrix([[-0.4846],
            [ 0.2546],
            [-0.8369]])

# test code

# q = matrix([[0.58564493386788],
#             [0.20407106724448],
#             [0.02456847506594],
#             [0.78407359411060]])

# phi = 1.33922635256429
# e = matrix([[0.94361701274567],
#             [0.32866855166594],
#             [0.03954638292888]])

# p = matrix([[0.74692597514675],
#             [0.20027029704522],
#             [0.03133439928404]])

# matrix calculations

I = matrix([[1., 0., 0.],
            [0., 1., 0.],
            [0., 0., 1.]])

qx = matrix([[0, -q[2, 0], q[1, 0]],
             [q[2, 0], 0, -q[0, 0]],
             [-q[1, 0], q[0, 0], 0]])

qv = matrix([[q[0, 0]],
            [q[1, 0]],
            [q[2, 0]]])

ex =  matrix([[0, -e[2, 0], e[1, 0]],
              [e[2, 0], 0, -e[0, 0]],
              [-e[1, 0], e[0, 0], 0]])


C_TI = (q[3, 0]**2 - (qv.T*qv)[0, 0])*I + 2*qv*qv.T - 2*q[3, 0]*qx

C1 = I*cos(phi) + (1 - cos(phi))*e*e.T - ex*sin(phi)

q2 = 1/sqrt(1 + (p.T*p)[0, 0])*matrix([[p[0, 0]],
                                       [p[1, 0]],
                                       [p[2, 0]],
                                       [1]])

q2x = matrix([[0, -q2[2, 0], q2[1, 0]],
             [q2[2, 0], 0, -q2[0, 0]],
             [-q2[1, 0], q2[0, 0], 0]])

q2v = matrix([[q2[0, 0]],
            [q2[1, 0]],
            [q2[2, 0]]])

C2 = (q2[3, 0]**2 - (q2v.T*q2v)[0, 0])*I + 2*q2v*q2v.T - 2*q2[3, 0]*q2x

# expected error calculations

phi1 = arccos((trace(C_TI*C1.T) - 1)/2)
phi2 = arccos((trace(C_TI*C2.T) - 1)/2)

e1m = degrees(phi1)
e2m = degrees(phi2)

e1b = pi/4*e1m
e2b = pi/4*e2m

# direction error

bT = C_TI*r

b1 = C1*r
b2 = C2*r

e1d = (b1.T*bT)[0, 0]
e2d = (b2.T*bT)[0, 0]

e1 = degrees(arccos(e1d))
e2 = degrees(arccos(e2d))

# output

print("True C_TI:")
print(C_TI)
print()
print("C1:")
print(C1)
print()
print("C2:")
print(C2)
print()
print("e1m:", e1m)
print("e2m:", e2m)
print()
print("e1b:", e1b)
print("e2b:", e2b)
print()

print("bT:")
print(bT)
print()
print("b1:")
print(b1)
print()
print("b2:")
print(b2)
print()
print("e1d:", e1d)
print("e2d:", e2d)
print()
print("e1:", e1)
print("e2:", e2)

# ---- imports ----

from numpy import array, matrix, cross, dot, sqrt, trace
from numpy.linalg import norm, eig

# ---- givens ----

# r1 = array([0.2150, -0.4476, -0.8680])
# r2 = array([-0.3295, -0.1675, 0.9292])

# b1 = array([0.2201, -0.3271, -0.9190])
# b2 = array([-0.2165, -0.3014, 0.9286])

r1 = array([0.1732, 0.3293, -0.9282])
r2 = array([-0.4056, -0.5613, 0.7214])
b1 = array([-0.3306, -0.3173, 0.8888])
b2 = array([0.5563, 0.5208, -0.6475])

alpha = 1/4

# ---- calculations ----

# triad
b1b2 = cross(b1, b2)/norm(cross(b1, b2))
b1b1b2 = cross(b1, cross(b1, b2))/norm(cross(b1, cross(b1, b2)))

r1r2 = cross(r1, r2)/norm(cross(r1, r2))
r1r1r2 = cross(r1, cross(r1, r2))/norm(cross(r1, cross(r1, r2)))

Cb = matrix([[b1[0], b1b2[0], b1b1b2[0]],
             [b1[1], b1b2[1], b1b1b2[1]],
             [b1[2], b1b2[2], b1b1b2[2]]])

Cr = matrix([[r1[0], r1r2[0], r1r1r2[0]],
             [r1[1], r1r2[1], r1r1r2[1]],
             [r1[2], r1r2[2], r1r1r2[2]]])

C = Cb*Cr.T

# q-method

r1m = matrix([[r1[0]], [r1[1]], [r1[2]]])
r2m = matrix([[r2[0]], [r2[1]], [r2[2]]])

b1m = matrix([[b1[0]], [b1[1]], [b1[2]]])
b2m = matrix([[b2[0]], [b2[1]], [b2[2]]])

B = alpha*(b1m*r1m.T) + alpha*(b2m*r2m.T)



I = matrix([[1., 0., 0.],
            [0., 1., 0.],
            [0., 0., 1.]])

k_ul = B + B.T - trace(B)*I
k_ur = alpha*cross(r1, b1) + alpha*cross(r2, b2)
k_ll = k_ur.T
k_lr = trace(B)

K = matrix([[k_ul[0, 0], k_ul[0, 1], k_ul[0, 2], k_ur[0]],
            [k_ul[1, 0], k_ul[1, 1], k_ul[1, 2], k_ur[1]],
            [k_ul[2, 0], k_ul[2, 1], k_ul[2, 2], k_ur[2]],
            [k_ll[0]   , k_ll[1]   , k_ll[2]   , k_lr   ]])

eigens = eig(K)
eig_val = eigens[0]
eig_vec = eigens[1]

eig_max = max(eig_val)
i = list(eig_val).index(eig_max)

q_opt = eig_vec[:, i]

# ------ output --------

print("------------- TRIAD -------------")
print("Cb:")
print(Cb)
print()
print("Cr:")
print(Cr)
print()
print("C:")
print(C)
print()
print("------------- q-Method -------------")
print("B:")
print(B)
print()
print("K:")
print(K)
print()
print("eigenvalues:")
print(eig_val)
print()
print("eigenvectors:")
print(eig_vec)
print()
print("max eigenvalue:")
print(eig_max)
print()
print("q opt:")
print(q_opt)
print()

import numpy as np
def rotationMatrixToQuaternion1(m):
    #q0 = qw
    t = np.matrix.trace(m)
    q = np.asarray([0.0, 0.0, 0.0, 0.0], dtype=np.float64)

    if(t > 0):
        t = np.sqrt(t + 1)
        q[3] = 0.5 * t
        t = 0.5/t
        q[0] = (m[2,1] - m[1,2]) * t
        q[1] = (m[0,2] - m[2,0]) * t
        q[2] = (m[1,0] - m[0,1]) * t

    else:
        i = 0
        if (m[1,1] > m[0,0]):
            i = 1
        if (m[2,2] > m[i,i]):
            i = 2
        j = (i+1)%3
        k = (j+1)%3

        t = np.sqrt(m[i,i] - m[j,j] - m[k,k] + 1)
        q[i] = 0.5 * t
        t = 0.5 / t
        q[3] = (m[k,j] - m[j,k]) * t
        q[j] = (m[j,i] + m[i,j]) * t
        q[k] = (m[k,i] + m[i,k]) * t

    return q


print(rotationMatrixToQuaternion1(C))
print(k_ur)